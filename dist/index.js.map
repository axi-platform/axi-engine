{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@feathersjs/commons/lib/arguments.js","webpack:///./node_modules/@feathersjs/commons/lib/commons.js","webpack:///./node_modules/@feathersjs/commons/lib/filter-query.js","webpack:///./node_modules/@feathersjs/commons/lib/hooks.js","webpack:///./node_modules/@feathersjs/commons/lib/utils.js","webpack:///./node_modules/@feathersjs/configuration/lib/index.js","webpack:///./node_modules/@feathersjs/errors/handler.js","webpack:///./node_modules/@feathersjs/errors/lib/error-handler.js","webpack:///./node_modules/@feathersjs/errors/lib/index.js","webpack:///./node_modules/@feathersjs/errors/lib/not-found-handler.js","webpack:///./node_modules/@feathersjs/errors/not-found.js","webpack:///./node_modules/@feathersjs/express/lib/index.js","webpack:///./node_modules/@feathersjs/express/lib/rest/index.js","webpack:///./node_modules/@feathersjs/express/lib/rest/wrappers.js","webpack:///./node_modules/@feathersjs/feathers/lib/application.js","webpack:///./node_modules/@feathersjs/feathers/lib/events.js","webpack:///./node_modules/@feathersjs/feathers/lib/hooks.js","webpack:///./node_modules/@feathersjs/feathers/lib/index.js","webpack:///./node_modules/@feathersjs/feathers/lib/version.js","webpack:///./node_modules/@feathersjs/socketio/lib/index.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/channels/channel/base.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/channels/channel/combined.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/channels/index.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/channels/mixins.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/index.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/routing.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/socket/index.js","webpack:///./node_modules/@feathersjs/transport-commons/lib/socket/utils.js","webpack:///./src/channels.js","webpack:///./src/core/kafka.js","webpack:///./src/hooks/index.js","webpack:///./src/hooks/logger.js","webpack:///./src/index.js","webpack:///./src/middleware/index.js","webpack:///./src/models/index.js","webpack:///./src/models/ticket.js","webpack:///./src/services/index.js","webpack:///./src/services/seating.js","webpack:///external \"compression\"","webpack:///external \"config\"","webpack:///external \"cors\"","webpack:///external \"debug\"","webpack:///external \"events\"","webpack:///external \"express\"","webpack:///external \"helmet\"","webpack:///external \"http\"","webpack:///external \"kafka-node\"","webpack:///external \"lodash\"","webpack:///external \"msgpack\"","webpack:///external \"path\"","webpack:///external \"radix-router\"","webpack:///external \"sequelize\"","webpack:///external \"serve-favicon\"","webpack:///external \"socket.io\"","webpack:///external \"uberproto\"","webpack:///external \"winston\""],"names":["channels","app","channel","on","connection","join","authResult","user","leave","publish","data","hook","client","Client","producer","HighLevelProducer","console","log","error","send","topic","payload","Promise","resolve","reject","payloads","messages","msgpack","pack","err","loadTopics","once","loadMetadataForTopics","results","Object","keys","metadata","asTopic","offset","queryTopics","pattern","topics","RegExp","filter","x","test","map","Processor","constructor","onProcess","onError","setup","consumer","Consumer","autoCommit","encoding","onMessage","value","meta","unpack","before","all","after","logger","winston","createLogger","level","loglevel","format","json","transports","Console","simple","Logger","ctx","debug","type","path","method","toJSON","JSON","stringify","configure","use","express","urlencoded","extended","get","static","rest","middleware","services","notFound","errorHandler","hooks","PORT","listen","shutdown","code","process","exit","shutdownEvents","forEach","event","module","exports","sequelize","Sequelize","dialect","storage","__dirname","logging","operatorsAliases","Op","pool","max","min","idle","Ticket","define","buyer","STRING","allowNull","seat","validate","isSeat","HelloService","find","params","status","SeatingService","TICKET_ADD","addTicket","sync","processor","seats","findAll","ticket","findOne","where","errors","NotFound","create","BadRequest","Unprocessable"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+CAA+C,OAAO;AACtD;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;;AAEA;AACA,kEAAkE,OAAO;AACzE;AACA;;AAEA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;;AAEA,iCAAiC,gBAAgB,qBAAqB;;;;;;;;;;;;ACLtE,OAAO,IAAI;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;;;;;;;;;;;ACrDA,OAAO,aAAa;;AAEpB;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS,aAAa;AACnE,qDAAqD,SAAS,mBAAmB;;AAEjF;AACA;AACA;AACA,uBAAuB;;AAEvB,YAAY;AACZ,GAAG;AACH;AACA,6BAA6B;;AAE7B,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6EAA6E;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,eAAe;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ,GAAG;AACH,YAAY;AACZ,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,gBAAgB,aAAa,kBAAkB;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,OAAO;AACZ;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;;AAEA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,8BAA8B;AAC9B;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU,EAAE;AAC/C;;AAEA;AACA,SAAS;AACT,iCAAiC,qBAAqB;AACtD;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,sFAAsF,KAAK;;AAE3F;;AAEA,YAAY,SAAS,KAAK,KAAK,EAAE,KAAK,GAAG,2BAA2B;AACpE;;;;;;;;;;;;ACtJA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA,4CAA4C,IAAI;;AAEhD;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;;;;;;;;;;AC7DA;;;;;;;;;;;;ACAA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;;AAEvC,uBAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,oCAAoC;AACvC;AACA;AACA,GAAG,OAAO;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,UAAU,GAAG,UAAU,KAAK,aAAa;AACpD;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,UAAU;;;;;;;;;;;;ACxP1C;;AAEA,4BAA4B,kBAAkB,KAAK;AACnD;AACA,WAAW,MAAM;AACjB,qCAAqC,0BAA0B;AAC/D,uCAAuC,MAAM;AAC7C;AACA;;;;;;;;;;;;ACRA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oHAAoH,iCAAiC;AACrJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,aAAa;;AAElE;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC3FD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2HAA2H,YAAY;AACvI;;AAEA;;AAEA;AACA,sBAAsB;AACtB;AACA,KAAK;;AAEL;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA,mCAAmC,IAAI;;AAEvC,WAAW,aAAa;AACxB,WAAW,gBAAgB;;AAE3B;AACA;AACA;;AAEA,kDAAkD,KAAK,qBAAqB,IAAI;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC5EA;AACA,OAAO,OAAO;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA,yBAAyB,OAAO,oBAAoB,QAAQ;AAC5D;;AAEA,4DAA4D,OAAO;AACnE;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;;AAEA,sCAAsC,OAAO,YAAY,QAAQ;;AAEjE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,8CAA8C,QAAQ;AACtD;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA,iBAAiB,QAAQ;;AAEzB,uCAAuC,cAAc;AACrD;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AACA,OAAO,eAAe;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,SAAS;AACnC;AACA;;AAEA;AACA,GAAG;;AAEH,kCAAkC;AAClC;AACA,0BAA0B,KAAK;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,SAAS,GAAG,QAAQ;AACxC;;AAEA;AACA;;AAEA;AACA,kEAAkE,SAAS;AAC3E;;AAEA;AACA;;AAEA,0CAA0C,SAAS;;AAEnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,wCAAwC,KAAK;;AAE7C;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtJA,OAAO,eAAe;AACtB;;AAEA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,uBAAuB;;AAEtC;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACpFA,OAAO,yCAAyC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C,kBAAkB,SAAS,gBAAgB;AAC1F;;AAEA;AACA;;AAEA;AACA,WAAW;AACX,SAAS;AACT;AACA,4CAA4C,eAAe,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC9IA,OAAO,QAAQ;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;ACtBA;;;;;;;;;;;;ACAA;AACA;AACA;AACA,OAAO,kBAAkB;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,uBAAuB,WAAW;;AAElC;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7CA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,UAAU;AACV;;AAEA;AACA;AACA,WAAW,wBAAwB;;AAEnC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtDA;AACA,OAAO,kCAAkC;AACzC;AACA,OAAO,mCAAmC;;AAE1C,OAAO,mCAAmC;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACzEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,MAAM;AAClC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClEA;AACA;AACA;;A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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","const paramCounts = {\n  find: 1,\n  get: 2,\n  create: 2,\n  update: 3,\n  patch: 3,\n  remove: 2\n};\n\nfunction isObjectOrArray (value) {\n  return typeof value === 'object' && value !== null;\n}\n\nexports.validateArguments = function validateArguments (method, args) {\n  // Check if the last argument is a callback which are no longer supported\n  if (typeof args[args.length - 1] === 'function') {\n    throw new Error('Callbacks are no longer supported. Use Promises or async/await instead.');\n  }\n\n  const methodParamCount = paramCounts[method];\n\n  // Check the number of arguments and throw an error if too many are provided\n  if (methodParamCount && args.length > methodParamCount) {\n    throw new Error(`Too many arguments for '${method}' method`);\n  }\n\n  // `params` is always the last argument\n  const params = args[methodParamCount - 1];\n\n  // Check if `params` is an object (can be undefined though)\n  if (params !== undefined && !isObjectOrArray(params)) {\n    throw new Error(`Params for '${method}' method must be an object`);\n  }\n\n  // Validate other arguments for each method\n  switch (method) {\n    case 'create':\n      if (!isObjectOrArray(args[0])) {\n        throw new Error(`A data object must be provided to the 'create' method`);\n      }\n      break;\n    case 'get':\n    case 'remove':\n    case 'update':\n    case 'patch':\n      if (args[0] === undefined) {\n        throw new Error(`An id must be provided to the '${method}' method`);\n      }\n\n      if ((method === 'update' || method === 'patch') && !isObjectOrArray(args[1])) {\n        throw new Error(`A data object must be provided to the '${method}' method`);\n      }\n  }\n\n  return true;\n};\n","const utils = require('./utils');\nconst hooks = require('./hooks');\nconst args = require('./arguments');\nconst filterQuery = require('./filter-query');\n\nmodule.exports = Object.assign({}, utils, args, { hooks, filterQuery });\n","const { _ } = require('./utils');\n\n// Officially supported query parameters ($populate is kind of special)\nconst PROPERTIES = ['$sort', '$limit', '$skip', '$select', '$populate'];\n\nfunction parse (number) {\n  if (typeof number !== 'undefined') {\n    return Math.abs(parseInt(number, 10));\n  }\n}\n\n// Returns the pagination limit and will take into account the\n// default and max pagination settings\nfunction getLimit (limit, paginate) {\n  if (paginate && paginate.default) {\n    const lower = typeof limit === 'number' ? limit : paginate.default;\n    const upper = typeof paginate.max === 'number' ? paginate.max : Number.MAX_VALUE;\n\n    return Math.min(lower, upper);\n  }\n\n  return limit;\n}\n\n// Makes sure that $sort order is always converted to an actual number\nfunction convertSort (sort) {\n  if (typeof sort !== 'object' || Array.isArray(sort)) {\n    return sort;\n  }\n\n  const result = {};\n\n  Object.keys(sort).forEach(key => {\n    result[key] = typeof sort[key] === 'object'\n      ? sort[key] : parseInt(sort[key], 10);\n  });\n\n  return result;\n}\n\n// Converts Feathers special query parameters and pagination settings\n// and returns them separately a `filters` and the rest of the query\n// as `query`\nmodule.exports = function (query, paginate) {\n  let filters = {\n    $sort: convertSort(query.$sort),\n    $limit: getLimit(parse(query.$limit), paginate),\n    $skip: parse(query.$skip),\n    $select: query.$select,\n    $populate: query.$populate\n  };\n\n  return { filters, query: _.omit(query, ...PROPERTIES) };\n};\n","const { each, pick } = require('./utils')._;\n\n// To skip further hooks\nconst SKIP = exports.SKIP = typeof Symbol !== 'undefined'\n  ? Symbol('__feathersSkipHooks')\n  : '__feathersSkipHooks';\n\nconst convertGetOrRemove = ([ id, params = {} ]) => ({ id, params });\nconst convertUpdateOrPatch = ([ id, data, params = {} ]) => ({ id, data, params });\n\n// Converters from service method arguments to hook object properties\nexports.converters = {\n  find (args) {\n    const [ params = {} ] = args;\n\n    return { params };\n  },\n  create (args) {\n    const [ data, params = {} ] = args;\n\n    return { data, params };\n  },\n  get: convertGetOrRemove,\n  remove: convertGetOrRemove,\n  update: convertUpdateOrPatch,\n  patch: convertUpdateOrPatch\n};\n\n// Create a hook object for a method with arguments `args`\n// `data` is additional data that will be added\nexports.createHookObject = function createHookObject (method, args, data = {}) {\n  const hook = exports.converters[method](args);\n\n  Object.defineProperty(hook, 'toJSON', {\n    value () {\n      return pick(this, 'type', 'method', 'path',\n        'params', 'id', 'data', 'result', 'error');\n    }\n  });\n\n  return Object.assign(hook, data, {\n    method,\n    // A dynamic getter that returns the path of the service\n    get path () {\n      const { app, service } = data;\n\n      if (!service || !app || !app.services) {\n        return null;\n      }\n\n      return Object.keys(app.services)\n        .find(path => app.services[path] === service);\n    }\n  });\n};\n\n// Fallback used by `makeArguments` which usually won't be used\nexports.defaultMakeArguments = function defaultMakeArguments (hook) {\n  const result = [];\n\n  if (typeof hook.id !== 'undefined') {\n    result.push(hook.id);\n  }\n\n  if (hook.data) {\n    result.push(hook.data);\n  }\n\n  result.push(hook.params || {});\n\n  return result;\n};\n\n// Turns a hook object back into a list of arguments\n// to call a service method with\nexports.makeArguments = function makeArguments (hook) {\n  switch (hook.method) {\n    case 'find':\n      return [ hook.params ];\n    case 'get':\n    case 'remove':\n      return [ hook.id, hook.params ];\n    case 'update':\n    case 'patch':\n      return [ hook.id, hook.data, hook.params ];\n    case 'create':\n      return [ hook.data, hook.params ];\n  }\n\n  return exports.defaultMakeArguments(hook);\n};\n\n// Converts different hook registration formats into the\n// same internal format\nexports.convertHookData = function convertHookData (obj) {\n  var hook = {};\n\n  if (Array.isArray(obj)) {\n    hook = { all: obj };\n  } else if (typeof obj !== 'object') {\n    hook = { all: [ obj ] };\n  } else {\n    each(obj, function (value, key) {\n      hook[key] = !Array.isArray(value) ? [ value ] : value;\n    });\n  }\n\n  return hook;\n};\n\n// Duck-checks a given object to be a hook object\n// A valid hook object has `type` and `method`\nexports.isHookObject = function isHookObject (hookObject) {\n  return typeof hookObject === 'object' &&\n    typeof hookObject.method === 'string' &&\n    typeof hookObject.type === 'string';\n};\n\n// Returns all service and application hooks combined\n// for a given method and type `appLast` sets if the hooks\n// from `app` should be added last (or first by default)\nexports.getHooks = function getHooks (app, service, type, method, appLast = false) {\n  const appHooks = app.__hooks[type][method] || [];\n  const serviceHooks = service.__hooks[type][method] || [];\n\n  if (appLast) {\n    // Run hooks in the order of service -> app -> finally\n    return serviceHooks.concat(appHooks);\n  }\n\n  return appHooks.concat(serviceHooks);\n};\n\nexports.processHooks = function processHooks (hooks, initialHookObject) {\n  let hookObject = initialHookObject;\n  let updateCurrentHook = current => {\n    // Either use the returned hook object or the current\n    // hook object from the chain if the hook returned undefined\n    if (current) {\n      if (current === SKIP) {\n        return SKIP;\n      }\n\n      if (!exports.isHookObject(current)) {\n        throw new Error(`${hookObject.type} hook for '${hookObject.method}' method returned invalid hook object`);\n      }\n\n      hookObject = current;\n    }\n\n    return hookObject;\n  };\n  // First step of the hook chain with the initial hook object\n  let promise = Promise.resolve(hookObject);\n\n  // Go through all hooks and chain them into our promise\n  hooks.forEach(fn => {\n    const hook = fn.bind(this);\n\n    if (hook.length === 2) { // function(hook, next)\n      promise = promise.then(hookObject => hookObject === SKIP ? SKIP : new Promise((resolve, reject) => {\n        hook(hookObject, (error, result) =>\n          error ? reject(error) : resolve(result)\n        );\n      }));\n    } else { // function(hook)\n      promise = promise.then(hookObject => hookObject === SKIP ? SKIP : hook(hookObject));\n    }\n\n    // Use the returned hook object or the old one\n    promise = promise.then(updateCurrentHook);\n  });\n\n  return promise\n    .then(() => hookObject)\n    .catch(error => {\n      // Add the hook information to any errors\n      error.hook = hookObject;\n      throw error;\n    });\n};\n\n// Add `.hooks` functionality to an object\nexports.enableHooks = function enableHooks (obj, methods, types) {\n  if (typeof obj.hooks === 'function') {\n    return obj;\n  }\n\n  let __hooks = {};\n\n  types.forEach(type => {\n    // Initialize properties where hook functions are stored\n    __hooks[type] = {};\n  });\n\n  // Add non-enumerable `__hooks` property to the object\n  Object.defineProperty(obj, '__hooks', {\n    value: __hooks\n  });\n\n  return Object.assign(obj, {\n    hooks (allHooks) {\n      each(allHooks, (obj, type) => {\n        if (!this.__hooks[type]) {\n          throw new Error(`'${type}' is not a valid hook type`);\n        }\n\n        const hooks = exports.convertHookData(obj);\n\n        each(hooks, (value, method) => {\n          if (method !== 'all' && methods.indexOf(method) === -1) {\n            throw new Error(`'${method}' is not a valid hook method`);\n          }\n        });\n\n        methods.forEach(method => {\n          const myHooks = this.__hooks[type][method] ||\n            (this.__hooks[type][method] = []);\n\n          if (hooks.all) {\n            myHooks.push.apply(myHooks, hooks.all);\n          }\n\n          if (hooks[method]) {\n            myHooks.push.apply(myHooks, hooks[method]);\n          }\n        });\n      });\n\n      return this;\n    }\n  });\n};\n","// Removes all leading and trailing slashes from a path\nexports.stripSlashes = function stripSlashes (name) {\n  return name.replace(/^(\\/*)|(\\/*)$/g, '');\n};\n\n// A set of lodash-y utility functions that use ES6\nconst _ = exports._ = {\n  each (obj, callback) {\n    if (obj && typeof obj.forEach === 'function') {\n      obj.forEach(callback);\n    } else if (_.isObject(obj)) {\n      Object.keys(obj).forEach(key => callback(obj[key], key));\n    }\n  },\n\n  some (value, callback) {\n    return Object.keys(value)\n      .map(key => [ value[key], key ])\n      .some(([val, key]) => callback(val, key));\n  },\n\n  every (value, callback) {\n    return Object.keys(value)\n      .map(key => [ value[key], key ])\n      .every(([val, key]) => callback(val, key));\n  },\n\n  keys (obj) {\n    return Object.keys(obj);\n  },\n\n  values (obj) {\n    return _.keys(obj).map(key => obj[key]);\n  },\n\n  isMatch (obj, item) {\n    return _.keys(item).every(key => obj[key] === item[key]);\n  },\n\n  isEmpty (obj) {\n    return _.keys(obj).length === 0;\n  },\n\n  isObject (item) {\n    return (typeof item === 'object' && !Array.isArray(item) && item !== null);\n  },\n\n  extend (...args) {\n    return Object.assign(...args);\n  },\n\n  omit (obj, ...keys) {\n    const result = _.extend({}, obj);\n    keys.forEach(key => delete result[key]);\n    return result;\n  },\n\n  pick (source, ...keys) {\n    const result = {};\n    keys.forEach(key => {\n      if (source[key] !== undefined) {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  },\n\n  // Recursively merge the source object into the target object\n  merge (target, source) {\n    if (_.isObject(target) && _.isObject(source)) {\n      Object.keys(source).forEach(key => {\n        if (_.isObject(source[key])) {\n          if (!target[key]) {\n            Object.assign(target, { [key]: {} });\n          }\n\n          _.merge(target[key], source[key]);\n        } else {\n          Object.assign(target, { [key]: source[key] });\n        }\n      });\n    }\n    return target;\n  }\n};\n\n// Return a function that filters a result object or array\n// and picks only the fields passed as `params.query.$select`\n// and additional `otherFields`\nexports.select = function select (params, ...otherFields) {\n  const fields = params && params.query && params.query.$select;\n\n  if (Array.isArray(fields) && otherFields.length) {\n    fields.push(...otherFields);\n  }\n\n  const convert = result => {\n    if (!Array.isArray(fields)) {\n      return result;\n    }\n\n    return _.pick(result, ...fields);\n  };\n\n  return result => {\n    if (Array.isArray(result)) {\n      return result.map(convert);\n    }\n\n    return convert(result);\n  };\n};\n\n// An in-memory sorting function according to the\n// $sort special query parameter\nexports.sorter = function sorter ($sort) {\n  return function (first, second) {\n    let comparator = 0;\n    _.each($sort, (modifier, key) => {\n      modifier = parseInt(modifier, 10);\n\n      if (first[key] < second[key]) {\n        comparator -= 1 * modifier;\n      }\n\n      if (first[key] > second[key]) {\n        comparator += 1 * modifier;\n      }\n    });\n    return comparator;\n  };\n};\n\n// Duck-checks if an object looks like a promise\nexports.isPromise = function isPromise (result) {\n  return _.isObject(result) &&\n    typeof result.then === 'function';\n};\n\nexports.makeUrl = function makeUrl (path, app = {}) {\n  const get = typeof app.get === 'function' ? app.get.bind(app) : () => {};\n  const env = get('env') || process.env.NODE_ENV;\n  const host = get('host') || process.env.HOST_NAME || 'localhost';\n  const protocol = (env === 'development' || env === 'test' || (env === undefined)) ? 'http' : 'https';\n  const PORT = get('port') || process.env.PORT || 3030;\n  const port = (env === 'development' || env === 'test' || (env === undefined)) ? `:${PORT}` : '';\n\n  path = path || '';\n\n  return `${protocol}://${host}${port}/${exports.stripSlashes(path)}`;\n};\n","const makeDebug = require('debug');\nconst path = require('path');\n\nconst debug = makeDebug('@feathersjs/configuration');\nconst config = require('config');\nconst separator = path.sep;\n\nfunction init () {\n  return function () {\n    let app = this;\n\n    const convert = current => {\n      const result = Array.isArray(current) ? [] : {};\n\n      Object.keys(current).forEach(name => {\n        let value = current[name];\n\n        if (typeof value === 'object' && value !== null) {\n          value = convert(value);\n        }\n\n        if (typeof value === 'string') {\n          if (value.indexOf('\\\\') === 0) {\n            value = value.replace('\\\\', '');\n          } else {\n            if (process.env[value]) {\n              value = process.env[value];\n            } else if (value.indexOf('.') === 0 || value.indexOf('..') === 0) {\n              // Make relative paths absolute\n              value = path.resolve(\n                path.join(config.util.getEnv('NODE_CONFIG_DIR')),\n                value.replace(/\\//g, separator)\n              );\n            }\n          }\n        }\n\n        result[name] = value;\n      });\n\n      return result;\n    };\n\n    const env = config.util.getEnv('NODE_ENV');\n    const conf = convert(config);\n\n    debug(`Initializing configuration for ${env} environment`);\n\n    if (!app || app === global) {\n      return conf;\n    }\n\n    Object.keys(conf).forEach(name => {\n      let value = conf[name];\n      debug(`Setting ${name} configuration value to`, value);\n      app.set(name, value);\n    });\n  };\n}\n\nmodule.exports = init;\nmodule.exports.default = init;\n","module.exports = require('./lib/error-handler');\n","const path = require('path');\nconst errors = require('./index');\n\nconst defaults = {\n  public: path.resolve(__dirname, 'public'),\n  logger: console\n};\nconst defaultHtmlError = path.resolve(defaults.public, 'default.html');\n\nmodule.exports = function (options = {}) {\n  options = Object.assign({}, defaults, options);\n\n  if (typeof options.html === 'undefined') {\n    options.html = {\n      401: path.resolve(options.public, '401.html'),\n      404: path.resolve(options.public, '404.html'),\n      default: defaultHtmlError\n    };\n  }\n\n  if (typeof options.json === 'undefined') {\n    options.json = {};\n  }\n\n  return function (error, req, res, next) {\n    // Log the error if it didn't come from a service method call\n    if (options.logger && typeof options.logger.error === 'function' && !res.hook) {\n      options.logger.error(error);\n    }\n\n    if (error.type !== 'FeathersError') {\n      let oldError = error;\n      error = new errors.GeneralError(oldError.message, {\n        errors: oldError.errors\n      });\n\n      if (oldError.stack) {\n        error.stack = oldError.stack;\n      }\n    }\n\n    error.code = !isNaN(parseInt(error.code, 10)) ? parseInt(error.code, 10) : 500;\n    const formatter = {};\n\n    // If the developer passed a custom function for ALL html errors\n    if (typeof options.html === 'function') {\n      formatter['text/html'] = options.html;\n    } else {\n      let file = options.html[error.code];\n      if (!file) {\n        file = options.html.default || defaultHtmlError;\n      }\n      // If the developer passed a custom function for individual html errors\n      if (typeof file === 'function') {\n        formatter['text/html'] = file;\n      } else {\n        formatter['text/html'] = function () {\n          res.set('Content-Type', 'text/html');\n          res.sendFile(file);\n        };\n      }\n    }\n\n    // If the developer passed a custom function for ALL json errors\n    if (typeof options.json === 'function') {\n      formatter['application/json'] = options.json;\n    } else {\n      let handler = options.json[error.code] || options.json.default;\n      // If the developer passed a custom function for individual json errors\n      if (typeof handler === 'function') {\n        formatter['application/json'] = handler;\n      } else {\n        // Don't show stack trace if it is a 404 error\n        if (error.code === 404) {\n          error.stack = null;\n        }\n\n        formatter['application/json'] = function () {\n          let output = Object.assign({}, error.toJSON());\n\n          if (process.env.NODE_ENV === 'production') {\n            delete output.stack;\n          }\n\n          res.set('Content-Type', 'application/json');\n          res.json(output);\n        };\n      }\n    }\n\n    res.status(error.code);\n\n    const contentType = req.headers['content-type'] || '';\n    const accepts = req.headers.accept || '';\n\n    // by default just send back json\n    if (contentType.indexOf('json') !== -1 || accepts.indexOf('json') !== -1) {\n      formatter['application/json'](error, req, res, next);\n    } else if (options.html && (contentType.indexOf('html') !== -1 || accepts.indexOf('html') !== -1)) {\n      formatter['text/html'](error, req, res, next);\n    } else {\n      // TODO (EK): Maybe just return plain text\n      formatter['application/json'](error, req, res, next);\n    }\n  };\n};\n","const debug = require('debug')('@feathersjs/errors');\n\nfunction FeathersError (msg, name, code, className, data) {\n  msg = msg || 'Error';\n\n  let errors;\n  let message;\n  let newData;\n\n  if (msg instanceof Error) {\n    message = msg.message || 'Error';\n\n    // NOTE (EK): This is typically to handle validation errors\n    if (msg.errors) {\n      errors = msg.errors;\n    }\n  } else if (typeof msg === 'object') { // Support plain old objects\n    message = msg.message || 'Error';\n    data = msg;\n  } else { // message is just a string\n    message = msg;\n  }\n\n  if (data) {\n    // NOTE(EK): To make sure that we are not messing\n    // with immutable data, just make a copy.\n    // https://github.com/feathersjs/errors/issues/19\n    newData = JSON.parse(JSON.stringify(data));\n\n    if (newData.errors) {\n      errors = newData.errors;\n      delete newData.errors;\n    } else if (data.errors) {\n      // The errors property from data could be\n      // stripped away while cloning resulting newData not to have it\n      // For example: when cloning arrays this property\n      errors = JSON.parse(JSON.stringify(data.errors));\n    }\n  }\n\n  // NOTE (EK): Babel doesn't support this so\n  // we have to pass in the class name manually.\n  // this.name = this.constructor.name;\n  this.type = 'FeathersError';\n  this.name = name;\n  this.message = message;\n  this.code = code;\n  this.className = className;\n  this.data = newData;\n  this.errors = errors || {};\n\n  debug(`${this.name}(${this.code}): ${this.message}`);\n  debug(this.errors);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, FeathersError);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n}\n\nfunction inheritsFrom (Child, Parent) {\n  Child.prototype = Object.create(Parent.prototype);\n  Child.prototype.constructor = Child;\n}\n\ninheritsFrom(FeathersError, Error);\n\n// NOTE (EK): A little hack to get around `message` not\n// being included in the default toJSON call.\nObject.defineProperty(FeathersError.prototype, 'toJSON', {\n  value: function () {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      className: this.className,\n      data: this.data,\n      errors: this.errors\n    };\n  }\n});\n\n// 400 - Bad Request\nfunction BadRequest (message, data) {\n  FeathersError.call(this, message, 'BadRequest', 400, 'bad-request', data);\n}\n\ninheritsFrom(BadRequest, FeathersError);\n\n// 401 - Not Authenticated\nfunction NotAuthenticated (message, data) {\n  FeathersError.call(this, message, 'NotAuthenticated', 401, 'not-authenticated', data);\n}\n\ninheritsFrom(NotAuthenticated, FeathersError);\n\n// 402 - Payment Error\nfunction PaymentError (message, data) {\n  FeathersError.call(this, message, 'PaymentError', 402, 'payment-error', data);\n}\n\ninheritsFrom(PaymentError, FeathersError);\n\n// 403 - Forbidden\nfunction Forbidden (message, data) {\n  FeathersError.call(this, message, 'Forbidden', 403, 'forbidden', data);\n}\n\ninheritsFrom(Forbidden, FeathersError);\n\n// 404 - Not Found\nfunction NotFound (message, data) {\n  FeathersError.call(this, message, 'NotFound', 404, 'not-found', data);\n}\n\ninheritsFrom(NotFound, FeathersError);\n\n// 405 - Method Not Allowed\nfunction MethodNotAllowed (message, data) {\n  FeathersError.call(this, message, 'MethodNotAllowed', 405, 'method-not-allowed', data);\n}\n\ninheritsFrom(MethodNotAllowed, FeathersError);\n\n// 406 - Not Acceptable\nfunction NotAcceptable (message, data) {\n  FeathersError.call(this, message, 'NotAcceptable', 406, 'not-acceptable', data);\n}\n\ninheritsFrom(NotAcceptable, FeathersError);\n\n// 408 - Timeout\nfunction Timeout (message, data) {\n  FeathersError.call(this, message, 'Timeout', 408, 'timeout', data);\n}\n\ninheritsFrom(Timeout, FeathersError);\n\n// 409 - Conflict\nfunction Conflict (message, data) {\n  FeathersError.call(this, message, 'Conflict', 409, 'conflict', data);\n}\n\ninheritsFrom(Conflict, FeathersError);\n\n// 411 - Length Required\nfunction LengthRequired (message, data) {\n  FeathersError.call(this, message, 'LengthRequired', 411, 'length-required', data);\n}\n\ninheritsFrom(LengthRequired, FeathersError);\n\n// 422 Unprocessable\nfunction Unprocessable (message, data) {\n  FeathersError.call(this, message, 'Unprocessable', 422, 'unprocessable', data);\n}\n\ninheritsFrom(Unprocessable, FeathersError);\n\n// 429 Too Many Requests\nfunction TooManyRequests (message, data) {\n  FeathersError.call(this, message, 'TooManyRequests', 429, 'too-many-requests', data);\n}\n\ninheritsFrom(TooManyRequests, FeathersError);\n\n// 500 - General Error\nfunction GeneralError (message, data) {\n  FeathersError.call(this, message, 'GeneralError', 500, 'general-error', data);\n}\n\ninheritsFrom(GeneralError, FeathersError);\n\n// 501 - Not Implemented\nfunction NotImplemented (message, data) {\n  FeathersError.call(this, message, 'NotImplemented', 501, 'not-implemented', data);\n}\n\ninheritsFrom(NotImplemented, FeathersError);\n\n// 502 - Bad Gateway\nfunction BadGateway (message, data) {\n  FeathersError.call(this, message, 'BadGateway', 502, 'bad-gateway', data);\n}\n\ninheritsFrom(BadGateway, FeathersError);\n\n// 503 - Unavailable\nfunction Unavailable (message, data) {\n  FeathersError.call(this, message, 'Unavailable', 503, 'unavailable', data);\n}\n\ninheritsFrom(Unavailable, FeathersError);\n\nconst errors = {\n  FeathersError,\n  BadRequest,\n  NotAuthenticated,\n  PaymentError,\n  Forbidden,\n  NotFound,\n  MethodNotAllowed,\n  NotAcceptable,\n  Timeout,\n  Conflict,\n  LengthRequired,\n  Unprocessable,\n  TooManyRequests,\n  GeneralError,\n  NotImplemented,\n  BadGateway,\n  Unavailable,\n  400: BadRequest,\n  401: NotAuthenticated,\n  402: PaymentError,\n  403: Forbidden,\n  404: NotFound,\n  405: MethodNotAllowed,\n  406: NotAcceptable,\n  408: Timeout,\n  409: Conflict,\n  411: LengthRequired,\n  422: Unprocessable,\n  429: TooManyRequests,\n  500: GeneralError,\n  501: NotImplemented,\n  502: BadGateway,\n  503: Unavailable\n};\n\nfunction convert (error) {\n  if (!error) {\n    return error;\n  }\n\n  const FeathersError = errors[error.name];\n  const result = FeathersError\n    ? new FeathersError(error.message, error.data)\n    : new Error(error.message || error);\n\n  if (typeof error === 'object') {\n    Object.assign(result, error);\n  }\n\n  return result;\n}\n\nmodule.exports = Object.assign({ convert }, errors);\n","const errors = require('./index');\n\nmodule.exports = function ({ verbose = false } = {}) {\n  return function (req, res, next) {\n    const { url } = req;\n    const message = `Page not found${verbose ? ': ' + url : ''}`;\n    next(new errors.NotFound(message, { url }));\n  };\n};\n","module.exports = require('./lib/not-found-handler');\n","const express = require('express');\nconst Proto = require('uberproto');\nconst errorHandler = require('@feathersjs/errors/handler');\nconst notFound = require('@feathersjs/errors/not-found');\nconst debug = require('debug')('@feathersjs/express');\n\nconst rest = require('./rest');\n\nfunction feathersExpress (feathersApp) {\n  if (!feathersApp) {\n    return express();\n  }\n\n  if (typeof feathersApp.setup !== 'function') {\n    throw new Error('@feathersjs/express requires a valid Feathers application instance');\n  }\n\n  if (!feathersApp.version || feathersApp.version < '3.0.0') {\n    throw new Error(`@feathersjs/express requires an instance of a Feathers application version 3.x or later (got ${feathersApp.version || 'unknown'})`);\n  }\n\n  const expressApp = express();\n  // An Uberproto mixin that provides the extended functionality\n  const mixin = {\n    use (location) {\n      let service;\n      let middleware = Array.from(arguments)\n        .slice(1)\n        .reduce(function (middleware, arg) {\n          if (typeof arg === 'function') {\n            middleware[service ? 'after' : 'before'].push(arg);\n          } else if (!service) {\n            service = arg;\n          } else {\n            throw new Error('Invalid options passed to app.use');\n          }\n          return middleware;\n        }, {\n          before: [],\n          after: []\n        });\n\n      const hasMethod = methods => methods.some(name =>\n        (service && !Array.isArray(service) && typeof service[name] === 'function')\n      );\n\n      // Check for service (any object with at least one service method)\n      if (hasMethod(['handle', 'set']) || !hasMethod(this.methods.concat('setup'))) {\n        debug('Passing app.use call to Express app');\n        return this._super.apply(this, arguments);\n      }\n\n      debug('Registering service with middleware', middleware);\n      // Since this is a serivce, call Feathers `.use`\n      feathersApp.use.call(this, location, service, { middleware });\n\n      return this;\n    },\n\n    listen () {\n      const server = this._super.apply(this, arguments);\n\n      this.setup(server);\n      debug('Feathers application listening');\n\n      return server;\n    }\n  };\n\n  // Copy all non-existing properties (including non-enumerables)\n  // that don't already exist on the Express app\n  Object.getOwnPropertyNames(feathersApp).forEach(prop => {\n    const feathersProp = Object.getOwnPropertyDescriptor(feathersApp, prop);\n    const expressProp = Object.getOwnPropertyDescriptor(expressApp, prop);\n\n    if (expressProp === undefined && feathersProp !== undefined) {\n      Object.defineProperty(expressApp, prop, feathersProp);\n    }\n  });\n\n  return Proto.mixin(mixin, expressApp);\n}\n\nmodule.exports = feathersExpress;\n\nObject.assign(module.exports, express, {\n  default: feathersExpress,\n  original: express,\n  rest,\n  notFound,\n  errorHandler\n});\n","const makeDebug = require('debug');\nconst wrappers = require('./wrappers');\n\nconst debug = makeDebug('@feathersjs/express/rest');\n\nfunction formatter (req, res, next) {\n  if (res.data === undefined) {\n    return next();\n  }\n\n  res.format({\n    'application/json': function () {\n      res.json(res.data);\n    }\n  });\n}\n\nfunction rest (handler = formatter) {\n  return function () {\n    const app = this;\n\n    if (typeof app.route !== 'function') {\n      throw new Error('@feathersjs/express/rest needs an Express compatible app. Feathers apps have to wrapped with feathers-express first.');\n    }\n\n    if (!app.version || app.version < '3.0.0') {\n      throw new Error(`@feathersjs/express/rest requires an instance of a Feathers application version 3.x or later (got ${app.version})`);\n    }\n\n    app.rest = wrappers;\n\n    app.use(function (req, res, next) {\n      req.feathers = { provider: 'rest' };\n      next();\n    });\n\n    // Register the REST provider\n    app.providers.push(function (service, path, options) {\n      const uri = `/${path}`;\n      const baseRoute = app.route(uri);\n      const idRoute = app.route(`${uri}/:__feathersId`);\n\n      let { middleware } = options;\n      let { before, after } = middleware;\n\n      if (typeof handler === 'function') {\n        after = after.concat(handler);\n      }\n\n      debug(`Adding REST provider for service \\`${path}\\` at base route \\`${uri}\\``);\n\n      // GET / -> service.find(params)\n      baseRoute.get(...before, app.rest.find(service), ...after);\n      // POST / -> service.create(data, params)\n      baseRoute.post(...before, app.rest.create(service), ...after);\n      // PATCH / -> service.patch(null, data, params)\n      baseRoute.patch(...before, app.rest.patch(service), ...after);\n      // PUT / -> service.update(null, data, params)\n      baseRoute.put(...before, app.rest.update(service), ...after);\n      // DELETE / -> service.remove(null, params)\n      baseRoute.delete(...before, app.rest.remove(service), ...after);\n\n      // GET /:id -> service.get(id, params)\n      idRoute.get(...before, app.rest.get(service), ...after);\n      // PUT /:id -> service.update(id, data, params)\n      idRoute.put(...before, app.rest.update(service), ...after);\n      // PATCH /:id -> service.patch(id, data, params)\n      idRoute.patch(...before, app.rest.patch(service), ...after);\n      // DELETE /:id -> service.remove(id, params)\n      idRoute.delete(...before, app.rest.remove(service), ...after);\n    });\n  };\n}\n\nrest.formatter = formatter;\n\nmodule.exports = rest;\n","const errors = require('@feathersjs/errors');\nconst { omit } = require('@feathersjs/commons')._;\n\nconst debug = require('debug')('@feathersjs/express/rest');\n\nconst statusCodes = {\n  created: 201,\n  noContent: 204,\n  methodNotAllowed: 405\n};\nconst methodMap = {\n  find: 'GET',\n  get: 'GET',\n  create: 'POST',\n  update: 'PUT',\n  patch: 'PATCH',\n  remove: 'DELETE'\n};\nconst allowedMethods = function (service) {\n  return Object.keys(methodMap)\n    .filter(method => typeof service[method] === 'function')\n    .map(method => methodMap[method])\n    // Filter out duplicates\n    .filter((value, index, list) => list.indexOf(value) === index);\n};\n\n// A function that returns the middleware for a given method and service\n// `getArgs` is a function that should return additional leading service arguments\nfunction getHandler (method, getArgs) {\n  return service => {\n    return function (req, res, next) {\n      const { query } = req;\n      const route = omit(req.params, '__feathersId');\n\n      res.setHeader('Allow', allowedMethods(service).join(','));\n\n      // Check if the method exists on the service at all. Send 405 (Method not allowed) if not\n      if (typeof service[method] !== 'function') {\n        debug(`Method '${method}' not allowed on '${req.url}'`);\n        res.status(statusCodes.methodNotAllowed);\n\n        return next(new errors.MethodNotAllowed(`Method \\`${method}\\` is not supported by this endpoint.`));\n      }\n\n      // Grab the service parameters. Use req.feathers\n      // and set the query to req.query merged with req.params\n      const params = Object.assign({\n        query, route\n      }, req.feathers);\n\n      Object.defineProperty(params, '__returnHook', {\n        value: true\n      });\n\n      // Run the getArgs callback, if available, for additional parameters\n      const args = getArgs(req, params);\n\n      debug(`REST handler calling \\`${method}\\` from \\`${req.url}\\``);\n\n      service[method](...args, true)\n        .then(hook => {\n          const data = hook.dispatch !== undefined ? hook.dispatch : hook.result;\n\n          res.data = data;\n          res.hook = hook;\n\n          if (hook.statusCode) {\n            res.status(hook.statusCode);\n          } else if (!data) {\n            debug(`No content returned for '${req.url}'`);\n            res.status(statusCodes.noContent);\n          } else if (method === 'create') {\n            res.status(statusCodes.created);\n          }\n\n          return next();\n        })\n        .catch(hook => {\n          const { error } = hook;\n\n          debug(`Error in handler: \\`${error.message}\\``);\n          res.hook = hook;\n\n          return next(hook.error);\n        });\n    };\n  };\n}\n\n// Returns no leading parameters\nfunction reqNone (req, params) {\n  return [ params ];\n}\n\n// Returns the leading parameters for a `get` or `remove` request (the id)\nfunction reqId (req, params) {\n  return [ req.params.__feathersId || null, params ];\n}\n\n// Returns the leading parameters for an `update` or `patch` request (id, data)\nfunction reqUpdate (req, params) {\n  return [ req.params.__feathersId || null, req.body, params ];\n}\n\n// Returns the leading parameters for a `create` request (data)\nfunction reqCreate (req, params) {\n  return [ req.body, params ];\n}\n\nmodule.exports = {\n  find: getHandler('find', reqNone),\n  get: getHandler('get', reqId),\n  create: getHandler('create', reqCreate),\n  update: getHandler('update', reqUpdate),\n  patch: getHandler('patch', reqUpdate),\n  remove: getHandler('remove', reqId)\n};\n","const debug = require('debug')('feathers:application');\nconst { stripSlashes } = require('@feathersjs/commons');\n\nconst Uberproto = require('uberproto');\nconst events = require('./events');\nconst hooks = require('./hooks');\nconst version = require('./version');\n\nconst Proto = Uberproto.extend({\n  create: null\n});\n\nconst application = {\n  init () {\n    Object.assign(this, {\n      version,\n      methods: [\n        'find', 'get', 'create', 'update', 'patch', 'remove'\n      ],\n      mixins: [],\n      services: {},\n      providers: [],\n      _setup: false,\n      settings: {}\n    });\n\n    this.configure(hooks());\n    this.configure(events());\n  },\n\n  get (name) {\n    return this.settings[name];\n  },\n\n  set (name, value) {\n    this.settings[name] = value;\n    return this;\n  },\n\n  disable (name) {\n    this.settings[name] = false;\n    return this;\n  },\n\n  disabled (name) {\n    return !this.settings[name];\n  },\n\n  enable (name) {\n    this.settings[name] = true;\n    return this;\n  },\n\n  enabled (name) {\n    return !!this.settings[name];\n  },\n\n  configure (fn) {\n    fn.call(this, this);\n\n    return this;\n  },\n\n  service (path, service) {\n    if (typeof service !== 'undefined') {\n      throw new Error('Registering a new service with `app.service(path, service)` is no longer supported. Use `app.use(path, service)` instead.');\n    }\n\n    const location = stripSlashes(path);\n    const current = this.services[location];\n\n    if (typeof current === 'undefined' && typeof this.defaultService === 'function') {\n      return this.use(`/${location}`, this.defaultService(location))\n        .service(location);\n    }\n\n    return current;\n  },\n\n  use (path, service, options = {}) {\n    if (typeof path !== 'string' || stripSlashes(path) === '') {\n      throw new Error(`'${path}' is not a valid service path.`);\n    }\n\n    const location = stripSlashes(path);\n    const isSubApp = typeof service.service === 'function' && service.services;\n    const isService = this.methods.concat('setup').some(name =>\n      (service && typeof service[name] === 'function')\n    );\n\n    if (isSubApp) {\n      const subApp = service;\n\n      Object.keys(subApp.services).forEach(subPath =>\n        this.use(`${location}/${subPath}`, subApp.service(subPath))\n      );\n\n      return this;\n    }\n\n    if (!isService) {\n      throw new Error(`Invalid service object passed for path \\`${location}\\``);\n    }\n\n    // If the service is already Uberproto'd use it directly\n    const protoService = Proto.isPrototypeOf(service) ? service : Proto.extend(service);\n\n    debug(`Registering new service at \\`${location}\\``);\n\n    // Add all the mixins\n    this.mixins.forEach(fn => fn.call(this, protoService, location, options));\n\n    if (typeof protoService._setup === 'function') {\n      protoService._setup(this, location);\n    }\n\n    // Run the provider functions to register the service\n    this.providers.forEach(provider =>\n      provider.call(this, protoService, location, options)\n    );\n\n    // If we ran setup already, set this service up explicitly\n    if (this._isSetup && typeof protoService.setup === 'function') {\n      debug(`Setting up service for \\`${location}\\``);\n      protoService.setup(this, location);\n    }\n\n    this.services[location] = protoService;\n\n    return this;\n  },\n\n  setup () {\n    // Setup each service (pass the app so that they can look up other services etc.)\n    Object.keys(this.services).forEach(path => {\n      const service = this.services[path];\n\n      debug(`Setting up service for \\`${path}\\``);\n\n      if (typeof service.setup === 'function') {\n        service.setup(this, path);\n      }\n    });\n\n    this._isSetup = true;\n\n    return this;\n  }\n};\n\nmodule.exports = application;\n","const { EventEmitter } = require('events');\nconst Proto = require('uberproto');\n\n// Returns a hook that emits service events. Should always be\n// used as the very last hook in the chain\nconst eventHook = exports.eventHook = function eventHook () {\n  return function (hook) {\n    const { app, service } = hook;\n    const eventName = app.eventMappings[hook.method];\n    const isHookEvent = service._hookEvents && service._hookEvents.indexOf(eventName) !== -1;\n\n    // If this event is not being sent yet and we are not in an error hook\n    if (eventName && isHookEvent && hook.type !== 'error') {\n      const results = Array.isArray(hook.result) ? hook.result : [ hook.result ];\n\n      results.forEach(element => service.emit(eventName, element, hook));\n    }\n  };\n};\n\n// Mixin that turns a service into a Node event emitter\nconst eventMixin = exports.eventMixin = function eventMixin (service) {\n  if (service._serviceEvents) {\n    return;\n  }\n\n  const app = this;\n  // Indicates if the service is already an event emitter\n  const isEmitter = typeof service.on === 'function' &&\n    typeof service.emit === 'function';\n\n  // If not, mix it in (the service is always an Uberproto object that has a .mixin)\n  if (typeof service.mixin === 'function' && !isEmitter) {\n    service.mixin(EventEmitter.prototype);\n  }\n\n  // Define non-enumerable properties of\n  Object.defineProperties(service, {\n    // A list of all events that this service sends\n    _serviceEvents: {\n      value: Array.isArray(service.events) ? service.events.slice() : []\n    },\n\n    // A list of events that should be handled through the event hooks\n    _hookEvents: {\n      value: []\n    }\n  });\n\n  // `app.eventMappings` has the mapping from method name to event name\n  Object.keys(app.eventMappings).forEach(method => {\n    const event = app.eventMappings[method];\n    const alreadyEmits = service._serviceEvents.indexOf(event) !== -1;\n\n    // Add events for known methods to _serviceEvents and _hookEvents\n    // if the service indicated it does not send it itself yet\n    if (typeof service[method] === 'function' && !alreadyEmits) {\n      service._serviceEvents.push(event);\n      service._hookEvents.push(event);\n    }\n  });\n};\n\nmodule.exports = function () {\n  return function (app) {\n    // Mappings from service method to event name\n    Object.assign(app, {\n      eventMappings: {\n        create: 'created',\n        update: 'updated',\n        remove: 'removed',\n        patch: 'patched'\n      }\n    });\n\n    // Register the event hook\n    // `finally` hooks always run last after `error` and `after` hooks\n    app.hooks({ finally: eventHook() });\n\n    // Make the app an event emitter\n    Proto.mixin(EventEmitter.prototype, app);\n\n    app.mixins.push(eventMixin);\n  };\n};\n","const { hooks, validateArguments, isPromise, _ } = require('@feathersjs/commons');\n\nconst {\n  createHookObject,\n  getHooks,\n  processHooks,\n  enableHooks,\n  makeArguments\n} = hooks;\n\n// A service mixin that adds `service.hooks()` method and functionality\nconst hookMixin = exports.hookMixin = function hookMixin (service) {\n  if (typeof service.hooks === 'function') {\n    return;\n  }\n\n  const app = this;\n  const methods = app.methods;\n  const mixin = {};\n\n  // Add .hooks method and properties to the service\n  enableHooks(service, methods, app.hookTypes);\n\n  // Assemble the mixin object that contains all \"hooked\" service methods\n  methods.forEach(method => {\n    if (typeof service[method] !== 'function') {\n      return;\n    }\n\n    mixin[method] = function () {\n      const service = this;\n      const args = Array.from(arguments);\n      // If the last argument is `true` we want to return\n      // the actual hook object instead of the result\n      const returnHook = args[args.length - 1] === true\n        ? args.pop() : false;\n\n      // A reference to the original method\n      const _super = service._super.bind(service);\n      // Create the hook object that gets passed through\n      const hookObject = createHookObject(method, args, {\n        type: 'before', // initial hook object type\n        service,\n        app\n      });\n      // A hook that validates the arguments and will always be the very first\n      const validateHook = context => {\n        validateArguments(method, args);\n\n        return context;\n      };\n      // The `before` hook chain (including the validation hook)\n      const beforeHooks = [ validateHook, ...getHooks(app, service, 'before', method) ];\n\n      // Process all before hooks\n      return processHooks.call(service, beforeHooks, hookObject)\n        // Use the hook object to call the original method\n        .then(hookObject => {\n          // If `hookObject.result` is set, skip the original method\n          if (typeof hookObject.result !== 'undefined') {\n            return hookObject;\n          }\n\n          // Otherwise, call it with arguments created from the hook object\n          const promise = _super(...makeArguments(hookObject));\n\n          if (!isPromise(promise)) {\n            throw new Error(`Service method '${hookObject.method}' for '${hookObject.path}' service must return a promise`);\n          }\n\n          return promise.then(result => {\n            hookObject.result = result;\n\n            return hookObject;\n          });\n        })\n        // Make a (shallow) copy of hookObject from `before` hooks and update type\n        .then(hookObject => Object.assign({}, hookObject, { type: 'after' }))\n        // Run through all `after` hooks\n        .then(hookObject => {\n          // Combine all app and service `after` and `finally` hooks and process\n          const afterHooks = getHooks(app, service, 'after', method, true);\n          const finallyHooks = getHooks(app, service, 'finally', method, true);\n          const hookChain = afterHooks.concat(finallyHooks);\n\n          return processHooks.call(service, hookChain, hookObject);\n        })\n        .then(hookObject =>\n          // Finally, return the result\n          // Or the hook object if the `returnHook` flag is set\n          returnHook ? hookObject : hookObject.result\n        )\n        // Handle errors\n        .catch(error => {\n          // Combine all app and service `error` and `finally` hooks and process\n          const errorHooks = getHooks(app, service, 'error', method, true);\n          const finallyHooks = getHooks(app, service, 'finally', method, true);\n          const hookChain = errorHooks.concat(finallyHooks);\n\n          // A shallow copy of the hook object\n          const errorHookObject = _.omit(Object.assign({}, error.hook, hookObject, {\n            type: 'error',\n            original: error.hook,\n            error\n          }), 'result');\n\n          return processHooks.call(service, hookChain, errorHookObject)\n            .catch(error => {\n              errorHookObject.error = error;\n\n              return errorHookObject;\n            })\n            .then(hook => {\n              if (returnHook) {\n                // Either resolve or reject with the hook object\n                return typeof hook.result !== 'undefined' ? hook : Promise.reject(hook);\n              }\n\n              // Otherwise return either the result if set (to swallow errors)\n              // Or reject with the hook error\n              return typeof hook.result !== 'undefined' ? hook.result : Promise.reject(hook.error);\n            });\n        });\n    };\n  });\n\n  service.mixin(mixin);\n};\n\nmodule.exports = function () {\n  return function (app) {\n    // We store a reference of all supported hook types on the app\n    // in case someone needs it\n    Object.assign(app, {\n      hookTypes: [ 'before', 'after', 'error', 'finally' ]\n    });\n\n    // Add functionality for hooks to be registered as app.hooks\n    enableHooks(app, app.methods, app.hookTypes);\n\n    app.mixins.push(hookMixin);\n  };\n};\n","const { hooks } = require('@feathersjs/commons');\nconst Proto = require('uberproto');\nconst Application = require('./application');\nconst version = require('./version');\n\nfunction createApplication () {\n  const app = {};\n\n  // Mix in the base application\n  Proto.mixin(Application, app);\n\n  app.init();\n\n  return app;\n}\n\ncreateApplication.version = version;\ncreateApplication.SKIP = hooks.SKIP;\n\nmodule.exports = createApplication;\n\n// For better ES module (TypeScript) compatibility\nmodule.exports.default = createApplication;\n","module.exports = '3.1.6';\n","const socketio = require('socket.io');\nconst Proto = require('uberproto');\nconst http = require('http');\nconst { socket: commons } = require('@feathersjs/transport-commons');\nconst debug = require('debug')('@feathersjs/socketio');\n\nconst socketKey = Symbol('@feathersjs/socketio/socket');\n\nfunction configureSocketio (port, options, config) {\n  if (typeof port !== 'number') {\n    config = options;\n    options = port;\n    port = null;\n  }\n\n  if (typeof options !== 'object') {\n    config = options;\n    options = {};\n  }\n\n  return function () {\n    const app = this;\n    const getParams = socket => socket.feathers;\n\n    if (!app.version || app.version < '3.0.0') {\n      throw new Error('@feathersjs/socketio is not compatible with this version of Feathers. Use the latest at @feathersjs/feathers.');\n    }\n\n    // Promise that resolves with the Socket.io `io` instance\n    // when `setup` has been called (with a server)\n    const done = new Promise(resolve => {\n      Proto.mixin({\n        listen (...args) {\n          if (typeof this._super === 'function') {\n            // If `listen` already exists\n            // usually the case when the app has been expressified\n            return this._super(...args);\n          }\n\n          const server = http.createServer();\n\n          this.setup(server);\n\n          return server.listen(...args);\n        },\n\n        setup (server) {\n          if (!this.io) {\n            const io = this.io = socketio\n              .listen(port || server, options);\n\n            io.use((socket, next) => {\n              const connection = {\n                provider: 'socketio'\n              };\n\n              Object.defineProperty(connection, socketKey, {\n                value: socket\n              });\n\n              socket.feathers = connection;\n\n              next();\n            });\n\n            io.use((socket, next) => {\n              socket.once('disconnect', () => {\n                const { channels } = app;\n\n                if (channels.length) {\n                  app.channel(app.channels).leave(getParams(socket));\n                }\n              });\n              next();\n            });\n\n            // In Feathers it is easy to hit the standard Node warning limit\n            // of event listeners (e.g. by registering 10 services).\n            // So we set it to a higher number. 64 should be enough for everyone.\n            io.sockets.setMaxListeners(64);\n          }\n\n          if (typeof config === 'function') {\n            debug('Calling SocketIO configuration function');\n            config.call(this, this.io);\n          }\n\n          resolve(this.io);\n\n          return this._super.apply(this, arguments);\n        }\n      }, app);\n    });\n\n    app.configure(commons({\n      done,\n      socketKey,\n      getParams,\n      emit: 'emit'\n    }));\n  };\n}\n\nmodule.exports = configureSocketio;\nmodule.exports.default = configureSocketio;\nmodule.exports.SOCKET_KEY = socketKey;\n","class Channel {\n  constructor (connections = [], data = null) {\n    this.connections = connections;\n    this.data = data;\n  }\n\n  get length () {\n    return this.connections.length;\n  }\n\n  leave (...connections) {\n    connections.forEach(current => {\n      if (typeof current === 'function') {\n        return this.leave(...this.connections.filter(current));\n      }\n\n      const index = this.connections.indexOf(current);\n\n      if (index !== -1) {\n        this.connections.splice(index, 1);\n      }\n    });\n\n    return this;\n  }\n\n  join (...connections) {\n    connections.forEach(connection => {\n      if (this.connections.indexOf(connection) === -1) {\n        this.connections.push(connection);\n      }\n    });\n\n    return this;\n  }\n\n  filter (fn) {\n    return new Channel(this.connections.filter(fn), this.data);\n  }\n\n  send (data) {\n    return new Channel(this.connections, data);\n  }\n}\n\nmodule.exports = Channel;\n","const Channel = require('./base');\n\nfunction collectConnections (children) {\n  const mappings = new WeakMap();\n  const connections = [];\n\n  children.forEach(channel => {\n    channel.connections.forEach(connection => {\n      if (!mappings.has(connection)) {\n        connections.push(connection);\n        mappings.set(connection, channel.data);\n      }\n    });\n  });\n\n  return { connections, mappings };\n}\n\nclass CombinedChannel extends Channel {\n  constructor (children, data = null) {\n    const { mappings, connections } = collectConnections(children);\n\n    super(connections, data);\n\n    this.children = children;\n    this.mappings = mappings;\n  }\n\n  refresh () {\n    const collected = collectConnections(this.children);\n\n    return Object.assign(this, collected);\n  }\n\n  _callChildren (method, connections) {\n    this.children.forEach(child => child[method](...connections));\n    this.refresh();\n\n    return this;\n  }\n\n  leave (...connections) {\n    return this._callChildren('leave', connections);\n  }\n\n  join (...connections) {\n    return this._callChildren('join', connections);\n  }\n\n  dataFor (connection) {\n    return this.mappings.get(connection);\n  }\n}\n\nmodule.exports = CombinedChannel;\n","const debug = require('debug')('@feathersjs/transport-commons/channels');\nconst { get, compact, flattenDeep, noop } = require('lodash');\nconst CombinedChannel = require('./channel/combined');\nconst { channelMixin, publishMixin, keys } = require('./mixins');\n\nconst { CHANNELS, PUBLISHERS, ALL_EVENTS } = keys;\n\nfunction channels () {\n  return app => {\n    if (typeof app.channel === 'function' && typeof app.publish === 'function') {\n      return;\n    }\n\n    Object.assign(app, channelMixin(), publishMixin());\n    Object.defineProperty(app, 'channels', {\n      get () {\n        return Object.keys(this[CHANNELS]);\n      }\n    });\n\n    app.mixins.push(function (service, path) {\n      if (typeof service.publish === 'function' || !service._serviceEvents) {\n        return;\n      }\n\n      Object.assign(service, publishMixin());\n\n      service._serviceEvents.forEach(event => {\n        service.on(event, function (data, hook) {\n          if (!hook) {\n            // Fake hook for custom events\n            hook = { path, service, app, result: data };\n          }\n\n          debug('Publishing event', event, hook.path);\n\n          const servicePublishers = service[PUBLISHERS];\n          const appPublishers = app[PUBLISHERS];\n          // This will return the first publisher list that is not empty\n          // In the following precedence\n          const callback = [\n            // 1. Service publisher for a specific event\n            get(servicePublishers, event),\n            // 2. Service publisher for all events\n            get(servicePublishers, ALL_EVENTS),\n            // 3. App publishers for a specific event\n            get(appPublishers, event),\n            // 4. App publishers for all events\n            get(appPublishers, ALL_EVENTS)\n          ].find(current => typeof current === 'function') || noop;\n\n          Promise.resolve(callback(data, hook)).then(result => {\n            if (!result) {\n              return;\n            }\n\n            const results = Array.isArray(result) ? compact(flattenDeep(result)) : [ result ];\n            const channel = new CombinedChannel(results);\n\n            if (channel && channel.length > 0) {\n              app.emit('publish', event, channel, hook, data);\n            } else {\n              debug('No connections to publish to');\n            }\n          });\n        });\n      });\n    });\n  };\n}\n\nchannels.keys = keys;\n\nmodule.exports = channels;\n","const debug = require('debug')('@feathersjs/transport-commons:channels/mixins');\nconst Channel = require('./channel/base');\nconst CombinedChannel = require('./channel/combined');\n\nconst PUBLISHERS = Symbol('@feathersjs/transport-commons/publishers');\nconst CHANNELS = Symbol('@feathersjs/transport-commons/channels');\nconst ALL_EVENTS = Symbol('@feathersjs/transport-commons/all-events');\n\nexports.keys = {\n  PUBLISHERS,\n  CHANNELS,\n  ALL_EVENTS\n};\n\nexports.channelMixin = function channelMixin () {\n  return {\n    [CHANNELS]: {},\n\n    channel (...names) {\n      debug('Returning channels', names);\n\n      if (names.length === 0) {\n        throw new Error('app.channel needs at least one channel name');\n      }\n\n      if (names.length === 1) {\n        const name = names[0];\n\n        if (Array.isArray(name)) {\n          return this.channel(...name);\n        }\n\n        return this[CHANNELS][name] ||\n          (this[CHANNELS][name] = new Channel());\n      }\n\n      const channels = names.map(name => this.channel(name));\n\n      return new CombinedChannel(channels);\n    }\n  };\n};\n\nexports.publishMixin = function publishMixin () {\n  return {\n    [PUBLISHERS]: {},\n\n    publish (event, callback) {\n      debug('Registering publisher', event);\n\n      if (!callback && typeof event === 'function') {\n        callback = event;\n        event = ALL_EVENTS;\n      }\n\n      if (this._serviceEvents && event !== ALL_EVENTS && this._serviceEvents.indexOf(event) === -1) {\n        throw new Error(`'${event}' is not a valid service event`);\n      }\n\n      const publishers = this[PUBLISHERS];\n\n      publishers[event] = callback;\n\n      return this;\n    }\n  };\n};\n","const socket = require('./socket');\nconst routing = require('./routing');\nconst channels = require('./channels');\n\nmodule.exports = { socket, routing, channels };\n","const Router = require('radix-router');\nconst { stripSlashes } = require('@feathersjs/commons');\nconst ROUTER = Symbol('@feathersjs/transport-commons/router');\n\nmodule.exports = function () {\n  return app => {\n    if (typeof app.lookup === 'function') {\n      return;\n    }\n\n    const router = new Router();\n\n    Object.assign(app, {\n      [ROUTER]: router,\n      lookup (path) {\n        return this[ROUTER].lookup(stripSlashes(path));\n      }\n    });\n\n    // Add a mixin that registers a service on the router\n    app.mixins.push((service, path) => {\n      app[ROUTER].insert({ path, service });\n      app[ROUTER].insert({\n        path: `${path}/:__id`,\n        service\n      });\n    });\n  };\n};\n\nmodule.exports.ROUTER = ROUTER;\n","const debug = require('debug')('@feathersjs/transport-commons');\n\nconst channels = require('../channels');\nconst routing = require('../routing');\n\nconst { getDispatcher, runMethod } = require('./utils');\n\nmodule.exports = function ({ done, emit, socketKey, getParams }) {\n  return app => {\n    app.configure(channels());\n    app.configure(routing());\n\n    app.on('publish', getDispatcher(emit, socketKey));\n\n    // `connection` event\n    done.then(provider => provider.on('connection', socket =>\n      app.emit('connection', getParams(socket)))\n    );\n\n    // `socket.emit('methodName', 'serviceName', ...args)` handlers\n    done.then(provider => provider.on('connection', socket => {\n      for (let method of app.methods) {\n        socket.on(method, (...args) => {\n          const path = args.shift();\n\n          debug(`Got '${method}' call for service '${path}'`);\n          runMethod(app, getParams(socket), path, method, args);\n        });\n      }\n    }));\n\n    // Legacy `socket.emit('serviceName::methodName', ...args)` handlers\n    app.mixins.push((service, path) => done.then(provider => {\n      provider.on('connection', socket => {\n        const methods = app.methods.filter(current =>\n          typeof service[current] === 'function'\n        );\n\n        for (let method of methods) {\n          const eventName = `${path}::${method}`;\n\n          socket.on(eventName, (...args) => {\n            debug(`Got legacy method call '${eventName}'`);\n            runMethod(app, getParams(socket), path, method, args);\n          });\n        }\n      });\n    }));\n  };\n};\n","const errors = require('@feathersjs/errors');\nconst debug = require('debug')('@feathersjs/transport-commons');\n\nconst paramsPositions = exports.paramsPositions = {\n  find: 0,\n  get: 1,\n  remove: 1,\n  create: 1,\n  update: 2,\n  patch: 2\n};\n\nconst normalizeError = exports.normalizeError = function (e) {\n  const hasToJSON = typeof e.toJSON === 'function';\n  const result = hasToJSON ? e.toJSON() : {};\n\n  if (!hasToJSON) {\n    Object.getOwnPropertyNames(e).forEach(key => {\n      result[key] = e[key];\n    });\n  }\n\n  if (process.env.NODE_ENV === 'production') {\n    delete result.stack;\n  }\n\n  delete result.hook;\n\n  return result;\n};\n\nexports.getDispatcher = function (emit, socketKey) {\n  return function (event, channel, hook, data) {\n    debug(`Dispatching '${event}' to ${channel.length} connections`);\n\n    channel.connections.forEach(connection => {\n      // The reference between connection and socket\n      // is set in `app.setup`\n      const socket = connection[socketKey];\n\n      if (socket) {\n        const eventName = `${hook.path || ''} ${event}`.trim();\n\n        let result = channel.dataFor(connection) || hook.dispatch || hook.result;\n\n        // If we are getting events from an array, try to get the individual\n        // item to dispatch from the correct index.\n        if (Array.isArray(hook.result) && Array.isArray(result)) {\n          result = result[hook.result.indexOf(data)];\n        }\n\n        debug(`Dispatching '${eventName}' to Socket ${socket.id} with`, result);\n\n        socket[emit](eventName, result);\n      }\n    });\n  };\n};\n\nexports.runMethod = function (app, connection, path, method, args) {\n  const trace = `method '${method}' on service '${path}'`;\n  const methodArgs = args.slice(0);\n  const callback = typeof methodArgs[methodArgs.length - 1] === 'function'\n    ? methodArgs.pop() : function () {};\n\n  debug(`Running ${trace}`, connection, args);\n\n  // A wrapper function that runs the method and returns a promise\n  const _run = () => {\n    const lookup = app.lookup(path);\n\n    // No valid service was found, return a 404\n    // just like a REST route would\n    if (lookup === null) {\n      return Promise.reject(new errors.NotFound(`Service '${path}' not found`));\n    }\n\n    const { service, params: route = {} } = lookup;\n\n    // Only service methods are allowed\n    if (paramsPositions[method] === undefined || typeof service[method] !== 'function') {\n      return Promise.reject(new errors.MethodNotAllowed(`Method '${method}' not allowed on service '${path}'`));\n    }\n\n    const position = paramsPositions[method];\n    const query = methodArgs[position] || {};\n    // `params` have to be re-mapped to the query\n    // and added with the route\n    const params = Object.assign({ query, route, connection }, connection);\n\n    methodArgs[position] = params;\n\n    return service[method](...methodArgs, true);\n  };\n\n  // Run and map to the callback that is being called for Socket calls\n  _run().then(hook => {\n    const result = hook.dispatch || hook.result;\n\n    debug(`Returned successfully ${trace}`, result);\n    callback(null, result);\n  }).catch(hook => {\n    const error = hook.type === 'error' ? hook.error : hook;\n\n    debug(`Error in ${trace}`, error);\n    callback(normalizeError(error));\n  });\n};\n","export default function channels(app) {\n  if (typeof app.channel !== 'function') {\n    // If no real-time functionality has been configured just return\n    return\n  }\n\n  app.on('connection', connection => {\n    app.channel('anonymous').join(connection)\n  })\n\n  app.on('login', (authResult, {connection}) => {\n    if (connection) {\n      // Obtain the logged in user from the connection\n      const user = connection.user\n\n      // The connection is no longer anonymous, remove it\n      app.channel('anonymous').leave(connection)\n\n      // Add it to the authenticated user channel\n      app.channel('authenticated').join(connection)\n\n      // Channels can be named anything and joined on any condition\n\n      // E.g. to send real-time events only to admins use\n      // if(user.isAdmin) { app.channel('admins').join(connection); }\n\n      // If the user has joined e.g. chat rooms\n      // if(Array.isArray(user.rooms)) user.rooms.forEach(room => app.channel(`rooms/${room.id}`).join(channel));\n\n      // Easily organize users by email and userid for things like messaging\n      // app.channel(`emails/${user.email}`).join(channel);\n      // app.channel(`userIds/$(user.id}`).join(channel);\n    }\n  })\n\n  // eslint-disable-next-line no-unused-vars\n  app.publish((data, hook) => {\n    // Here you can add event publishers to channels set up in `channels.js`\n    // To publish only for a specific event use `app.publish(eventname, () => {})`\n\n    // TODO: Restrict events to only authenticated users?\n\n    // e.g. to publish all service events to all authenticated users use\n    return app.channel('authenticated')\n  })\n\n  // Here you can also add service specific event publishers\n  // e..g the publish the `users` service `created` event to the `admins` channel\n  // app.service('users').publish('created', () => app.channel('admins'));\n\n  // With the userid and email organization from above you can easily select involved users\n  // app.service('messages').publish(() => {\n  //   return [\n  //     app.channel(`userIds/${data.createdBy}`),\n  //     app.channel(`emails/${data.recipientEmail}`)\n  //   ];\n  // });\n}\n","import {HighLevelProducer, Consumer, Client} from 'kafka-node'\nimport msgpack from 'msgpack'\n\nexport const client = new Client()\n\nexport const producer = new HighLevelProducer(client)\n\nproducer.on('ready', () => {\n  console.log('[+] Producer is now ready.')\n})\n\nproducer.on('error', console.error)\n\nexport function send(topic, payload) {\n  return new Promise((resolve, reject) => {\n    const payloads = [{topic, messages: msgpack.pack(payload)}]\n\n    producer.send(payloads, (err, data) => {\n      if (err) return reject(err)\n\n      resolve(data)\n    })\n  })\n}\n\n// Load all topics\nexport function loadTopics() {\n  return new Promise((resolve, reject) => {\n    client.once('connect', () => {\n      client.loadMetadataForTopics([], (err, results) => {\n        if (err) return reject(err)\n\n        resolve(Object.keys(results[1].metadata))\n      })\n    })\n  })\n}\n\nexport const asTopic = topic => ({topic, offset: 0})\n\n// Retrieves a list of topics that matches the pattern\nexport async function queryTopics(pattern) {\n  const topics = await loadTopics()\n\n  if (!(pattern instanceof RegExp)) {\n    pattern = new RegExp(pattern)\n  }\n\n  return topics.filter(x => pattern.test(x)).map(asTopic)\n}\n\nexport class Processor {\n  constructor(topic, onProcess, onError) {\n    if (onProcess) this.onProcess = onProcess\n    if (onError) this.onError = onProcess\n\n    this.setup(topic)\n  }\n\n  setup = async topic => {\n    const topics = await queryTopics(topic)\n\n    this.consumer = new Consumer(client, topics, {\n      autoCommit: true,\n      encoding: 'buffer',\n    })\n\n    this.consumer.on('message', this.onMessage)\n    this.consumer.on('error', this.onError)\n    this.consumer.on('offsetOutOfRange', this.onError)\n  }\n\n  onProcess() {\n    console.log('[!] Please override onProcess()')\n  }\n\n  onError(error) {\n    console.error('[!] Kafka Error:', error)\n  }\n\n  onMessage = ({topic, value, ...meta}) => {\n    this.onProcess(topic, msgpack.unpack(value), meta)\n  }\n}\n","import logger from './logger'\n\nconst before = {\n  all: [logger()],\n}\n\nconst after = {\n  all: [logger()],\n}\n\nconst error = {\n  all: [logger()],\n}\n\nexport default {before, after, error}\n","import winston from 'winston'\nimport {loglevel} from 'config'\n\nconst logger = winston.createLogger({\n  level: loglevel,\n  format: winston.format.json(),\n  transports: [\n    new winston.transports.Console({\n      format: winston.format.simple(),\n    }),\n  ],\n})\n\nconst Logger = () => async ctx => {\n  logger.debug(`${ctx.type} ${ctx.path}/${ctx.method}`)\n\n  if (typeof ctx.toJSON === 'function') {\n    logger.debug('Hook Context', JSON.stringify(ctx, null, '  '))\n  }\n\n  if (ctx.error) {\n    logger.error(ctx.error)\n  }\n}\n\nexport default Logger\n","import path from 'path'\nimport favicon from 'serve-favicon'\nimport compress from 'compression'\nimport cors from 'cors'\nimport helmet from 'helmet'\nimport logger from 'winston'\n\nimport feathers from '@feathersjs/feathers'\nimport configuration from '@feathersjs/configuration'\nimport express from '@feathersjs/express'\nimport socketio from '@feathersjs/socketio'\n\nimport middleware from './middleware'\nimport services from './services'\nimport hooks from './hooks'\nimport channels from './channels'\n\nconst app = express(feathers())\n\napp.configure(configuration())\n\napp.use(cors())\napp.use(helmet())\napp.use(compress())\napp.use(express.json())\napp.use(express.urlencoded({extended: true}))\napp.use(favicon(path.join(app.get('public'), 'favicon.ico')))\n\napp.use('/', express.static(app.get('public')))\n\napp.configure(express.rest())\napp.configure(socketio())\n\napp.configure(middleware)\napp.configure(services)\napp.configure(channels)\n\napp.use(express.notFound())\napp.use(express.errorHandler({logger}))\n\napp.hooks(hooks)\n\nconst PORT = app.get('port')\n\napp.listen(PORT).on('listening', () => {\n  console.log('💖', `The Axi Engine is now listening on Port ${PORT}!`)\n})\n\nfunction shutdown(code) {\n  console.log('[!] Shutting Down:', code)\n\n  process.exit()\n}\n\nconst shutdownEvents = ['SIGINT', 'SIGQUIT', 'SIGTERM', 'SIGHUP', 'SIGSTP']\n\nshutdownEvents.forEach(event => process.on(event, shutdown))\n\nexport default app\n","// eslint-disable-next-line no-unused-vars\nmodule.exports = function(app) {\n  // Add your custom middleware here. Remember, that\n  // in Express the order matters\n}\n","import Sequelize from 'sequelize'\nimport path from 'path'\n\nconst sequelize = new Sequelize('sequelize', '', '', {\n  dialect: 'sqlite',\n  storage: path.join(__dirname, 'db.sqlite'),\n  logging: false,\n  operatorsAliases: Sequelize.Op,\n  pool: {\n    max: 5,\n    min: 0,\n    idle: 10000,\n  },\n})\n\nexport default sequelize\n","import Sequelize from 'sequelize'\n\nimport sequelize from './index'\n\nconst Ticket = sequelize.define('ticket', {\n  buyer: {\n    type: Sequelize.STRING,\n    allowNull: false,\n  },\n  seat: {\n    type: Sequelize.STRING,\n    allowNull: false,\n    validate: {\n      isSeat(seat) {\n        console.log('[+] Seat Validation:', seat)\n\n        return true\n      },\n    },\n  },\n})\n\nexport default Ticket\n","import SeatingService from './seating'\n\nclass HelloService {\n  async find(params) {\n    return {status: 200, data: 'Hello, World!'}\n  }\n}\n\nexport default async function(app) {\n  app.use('/hello', new HelloService())\n  app.use('/seating', new SeatingService())\n}\n","import errors from '@feathersjs/errors'\n\nimport Ticket from '../models/ticket'\nimport {Processor, send} from '../core/kafka'\n\nconst TICKET_ADD = 'queuing.ticket.add'\n\nexport default class SeatingService {\n  async setup(app) {\n    await Ticket.sync()\n\n    this.app = app\n    this.processor = new Processor('queuing.ticket.*', this.process)\n  }\n\n  async find(params) {\n    const seats = await Ticket.findAll()\n\n    return {seats}\n  }\n\n  async get(seat, params) {\n    const ticket = await Ticket.findOne({where: {seat}})\n\n    if (!ticket) {\n      throw new errors.NotFound(`Seat ${seat} is currently empty.`)\n    }\n\n    return {status: 'BOOKED', data: ticket}\n  }\n\n  async create({seat, buyer}) {\n    const ticket = await Ticket.findOne({where: {seat}})\n\n    if (!seat || !buyer) {\n      throw new errors.BadRequest('The seat and buyer fields are required.')\n    }\n\n    if (ticket) {\n      throw new errors.Unprocessable('This seat had been taken.')\n    }\n\n    await send(TICKET_ADD, {buyer, seat})\n\n    return {status: 'PROCESSING', seat, buyer}\n  }\n\n  process = async (topic, payload) => {\n    console.log('[?] Incoming Event:', topic, '=>', payload)\n\n    if (topic === TICKET_ADD) {\n      this.addTicket(payload)\n    }\n  }\n\n  async addTicket({seat, buyer}) {\n    const ticket = await Ticket.findOne({where: {seat}})\n\n    if (ticket) {\n      console.error('[!!] Seat', seat, 'had been taken by', ticket.buyer)\n      return\n    }\n\n    await Ticket.create({seat, buyer})\n\n    console.log('[+] Seat', seat, 'has been bought by', buyer)\n  }\n}\n","module.exports = require(\"compression\");","module.exports = require(\"config\");","module.exports = require(\"cors\");","module.exports = require(\"debug\");","module.exports = require(\"events\");","module.exports = require(\"express\");","module.exports = require(\"helmet\");","module.exports = require(\"http\");","module.exports = require(\"kafka-node\");","module.exports = require(\"lodash\");","module.exports = require(\"msgpack\");","module.exports = require(\"path\");","module.exports = require(\"radix-router\");","module.exports = require(\"sequelize\");","module.exports = require(\"serve-favicon\");","module.exports = require(\"socket.io\");","module.exports = require(\"uberproto\");","module.exports = require(\"winston\");"],"sourceRoot":""}